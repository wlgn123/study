소프트웨어 공학
  소프트웨어
    프로그램 + 프로그램의 개발, 운용, 보수에 필요한 정보 일체
    개념적이고 무형적(생산물의 구조가 코드안에 숨어있음)
  소프트웨어의 유형
    응용 소프트웨어
    시스템 소프트웨어
    주문형 소프트웨어
    패키지 소프트웨어
    임베디드 소프트웨어
  시스템
    필요한 기능을 실현시키기 위하여 관련 요소를 어떤 법칙에 따라 조합한 집합체
  시스템의 성질
    서브시스템
    기능적 분할
      시스템은 규모가 작은 부속 시스템들로 나눌 수 있다.
    시스템 경계
      시스템은 어떤 것이건 시스템과 주변 환경을 구분할 수 있는 경계가있다.
      (입력과 출력이 만나는 곳)
    자동화 경계
      시스템이 자동화된 부분과 수동작업 부분을 나누는 경계

소프트웨어 공학의 필요성
  소프트웨어 공학은 소프트웨어에 있는 심각한 직접적인 손해 또는 간접적인 손해가 따를 수 있는
  문제를 해결

  소프트웨어 제품은 고객의 문제를 해결하기 위해 구축, 비즈니스를 운영하기 위하여
  사용한다.

  소프트웨어가 제대로 작동하지 않으면 재정적 손실이 크고 사용자가 불편을 겪음

비용 산출
  LOC(Lines Of Code) : 소프트웨어의 규모를 측정하는데 가장 널리 사용한다.
      (라인단위로 비용을 매김.)
  MM(Man-Month) : 소프트웨어 개발에 드는 비용
    (한달안에 소프트웨어를 몇명이서 개발할수 있는가의 단위)
    (ex 7MM => 7명이서 한달에 작업해야될 정도의 소프트웨어)
    -> 역으로 1명이 한다면 7달이 걸린다고 할 수 있음.
  생산성 : MM당 생산하는 프로그램의 LOC

  소프트웨어 공학
    소프트웨어의 개발과 운영, 유지보수, 소멸에 대한 체계적인 접근 방법
      체계적인 접근 : 소프트웨어 개발에 사용되는 방법이 일회성이 아닌 반복사용이 가능함.

  품질을 나타내는 속성
    기능성
      내재된 요구를 만족시키는 기능을 제공하는 능력
    신뢰성
      소프트웨어가 정해진 수준의 성능을 유지할 수 있는 능력
    사용용이성
      쉽게 이해되고 배울 수 있고 사용될 수 있는 능력
    효율성
      사용되는 자원의 양에 따라 적절한 성능을 제공할 수 있는 능력
    유지보수성
      정정, 개선, 적응시킬 목적으로 수정될 수 있는 능력
    이식성
      별도의 작동이나 수단 없이 다양한 환경에서 적응될 수 있는 능력

  일관성
    프로젝트의 결과를 어느 정도 정확하게 예측가능
    더 높은 품질의 제품을 생산
  프로세스의 표준화
    ISO 9001 -> 국제표준화 기구
  재현성
    개발하는 시스템 마다 높은 품질과 생산성을 갖도록 만드는 것
    개발 능력, 결과의 재현성

  오늘날 비즈니스 환경 변화는 매우 빠름
    소프트웨어 또한 시장에 따라 계속 진화하고 변경됨
    소프트웨어는 변경을 어렵게 하는 물리적인 부분이 없다.

  품질을 좌우하는 세가지 : 인력 , 프로세스 , 기술

  소프트웨어 공학 -> 소프트웨어 제작과정에 집중

  소프트웨어 엔지니어링 작업의 종류
    소프트웨어 개발 프로세스
      시스템에 대한 비젼과 개념을 목표로 하는 컴퓨터 환경에 실행되는 소프트웨어로 바꾸는 작업
    품질보증(SQA)
      개발작업이 적절히 수행되었는지 확인
    프로젝트 관리
      개발과 품질보증 작업을 관리하고 감독

    단계적 개발 프로세스를 따르는 이유
      소프트웨어의 문제를 나눠 여러 개발 단계에서 다른 관점을 다루기 때문
      개발하는 동안 정해진 시점에 품질과 진행을 체크할 수 있음.

  단계적 개발 프로세스
    요구분석
      소프트웨어 시스템이 풀어야 할 문제를 이해하기 위한 작업
        문제를 분석 : 문제와 그 배경을 잘 이해하고 개발할 시스템의 요구 찾기
        요구를 정리 : 요구명세서
    설계
      요구문서에 기술된 문제의 솔루션을 계획
        요구를 어떻게 만족시킬 것인지 추구
    코딩
      시스템 설계를 프로그래밍 언어로 변환
        코딩 작업 중에는 읽기 쉽고 이해하기 쉬운 프로그램이 되어야 한다.
        단순함과 명확성을 추구
    테스팅
      소프트웨어의 결함을 찾아냄
        소프트웨어 개발 단계에서 사용되는 중요한 품질 제어 수단
        프로그램에 포함된 요구, 설계, 코딩 오류를 밝힘
        단위 테스팅 : 모듈이나 컴포넌트를 개별적으로 테스트
        통합 테스팅 : 모듈 사이의 연결을 시험
        인수 테스팅 : 시스템이 잘 실행되는지 고겍에게 데모를 시켜본다
  일반적인 개발 단계
    분석
    설계
    구현
    테스팅

  품질 보증
    개발되고 있는 소프트웨어가 요구와 품질 수준을 만족시킬 것이라는 것을 보장하는 작업

  검토
    개발작업이 프로젝트를 위해 선택된 프로세스와 방법에 맞게 수행되었는지 체크
    요구된 소프트웨어 결과물이 품질 수준에 맞게 생산되었는지 검사
  확인
    개발 프로세스에 의하여 생성된 결과물의 정확성을 체크한다.
      정적확인
        소프트웨어를 실행시키지 않고 결과물의 정확성을 체크
      동적확인
        소프트웨어를 실행시켜 잘 작동하는지 확인
  테스팅
    동적 확인 작업, 테스트 결과가 예상되는 결과와 일치하는지 체크한다.

프로젝트 관리
  프로세스와 관련된 이슈를 적절히 관리
    작업과정에 자원을 어떤 작업에 할당할 것인지 기술
    소프트웨어 계획은 프로젝트의 개발 프로세스를 모니터링하고 제어하는데 사용되는 기준이 됨
  프로세스관리
    객관적인 데이터가 필요, 소프트웨어 메트릭이 사용
      프로덕트 메트릭 : 개발한 프로덕트, 소프트웨어 자체의 특성을 계량화
      프로세스 메트릭 : 소프트웨어 개발에 사용된 프로세스의 생산성을 계량화


챕터 2
  프로세스
    어떤 일을 하기 위한 특별한 방법으로 일반적으로 단계나 작업으로 구성됨
  소프트웨어 개발하는 과정 , 즉 작업 순서
    순서제약이 있는 작업의 집합(순서대로 처리 해야한다)
    높은 품질과 생산성이 목표
  프로세스가 없는개발
    Code-And-Fix
      (프로그래밍 -> 만족할 때까지 수정 -> 개선을 위한 아이디어 짜내기 -> 만족할 때 까지 수정(반복))
      -> 문제점
        요구나 설계 작업의 중요성을 깨닫지 못함
          즉흥적인 방법으로는 사용자의 높은 요구 수준에 도달하기 어렵다.
          계속 고치는 작업이 필요하다.
        신중하게 잘 설계하지 않으면 소프트웨어 구조가 나빠진다.
          즉흥적인 방법은 설계를 해도 되고 안 해도 되는 작업이므로 잘 설계되지 않는다.
        계획이 없어서 작업의 목표가 없음
          일을 한 후에도 잘한 것인지 못한 것이지 판단할 수가 없음
          비용과 일정의 조절을 할 수가 없음
        체계적인 테스트 작업이나 품질 보증 차원의 활동에 대한 인식이 없음
          발견되지 않은 결함이 남아 계속 고치게 됨
          시스템이 더욱 악화

프로세스 VS 방법론
  프로세스
    단계적인 작업의 틀을 정의한 것
    무엇을 하는가에 중점을 둔다.
    결과물의 표현에 대하여 언급이 없다.
    각 단계가 다른 방법론으로도 실현 가능(각 단계가 각자 다른 방법론으로 구현가능)
  프로세스 모델
     폭포수 프로세스, 나선형 프로세스, 프로토타이핑, 애자일, Unified
            -> 이미 누가 정해준 (일반적인) 프로세스 단계들

  방법론
    프로세스의 구체적인 구현에 이름
    어떻게 하는가에 중점
    결과물을 어떻게 표현하는지 표현
    각 단계의 절차, 기술, 가이드라인을 제시

  -> 구조적 분석, 설계 방법론
      객체지향 방법론, 컴포넌트, 애자일 방법론

소프트웨어 프로세스
  소프트웨어 개발에 대한 기술적, 관리적 이슈를 다루는 작업
    개발 모델별 컴포넌트 프로세스, 부 프로세스 존재
    서로 다른 목적
    서로 협력하여 전체 목적을 만족

프로세스와 프로세스 모델
  소프트웨어 프로젝트
    수행할 작업을 조직화한 프로세스를 이용
    비용, 일정, 품질에 대한 목표를 성취하는것
  프로세스 명세
    프로젝트에서 수행하여야 하는 작업과 이들ㅈ의 수행 순서를 정의해놓은것
    실행 프로세스는 다를 수 있음
  프로세스 모델
    일반적인 프로세스를 기술한 것
    작업의 단계와 순서
    각 단계 작업 수행의 제약사항이나 조건 등을 모아 놓은 것
  프로젝트 중심 프로세스
    개발 프로세스
    관리 프로세스
  기타 프로세스
    형상 관리 프로세스
    프로젝트 관리 프로세스
    프로세스 관리 프로세스

  프로세스의 정의
    작업 결과와 검증 조건을 명확히 정의하여야 한다
    작업 방법
    진입 조건, 출구 조건
                      v 제어                    -> 프로세스 관리를 위한 정보
  입력(진입조건)   -> 프로세스 단계 -> 검토와 검증 ->  출력(출구조건)

  바람직한 프로세스의 특징
    변수를 예측할 수 있음(예측가능성)
    테스팅과 유지보수 지원
    변경 지원 - 변경을 쉽게 다룰 수 있는 프로세스
    결함제거
    오류 수정비용
      개발단계가 나아갈수록 오류 수정에 대한 비용이 증가한다.

  프로세스 모델
    일반적인 모델이 될만한 프로세스를 기술한 것
  대표적인 프로세스 모델
    폭포수 모델
    프로토타이핑 모델
    점증적 모델
    V 모델
    일정 중심 설계 모델
    진화적 출시 모델
    애자일 모델

  소프트웨어 생명주기
    개발전 -> 개념화 단계 -> 유아 및 성장기 -> 성년기 -> 장년기 -> 개발후
                          -> 개발 단계
설계
  다음 질문의 대답을 찾는 단계
    How much will it cot(얼마정도의 비율)
    How long will it take?(얼마정도의 시간)
    How many people will it take?(몇멍의 인원이 필요할까)
    What might go wrong?(어떤 문제점이 일어날까?)

  범위 정하기
  산정(Estimation)
  리스크 분석
  일정 계획
  관리 전략 수립

요구 분석
  요구 - 시스템이 가져야 할 능력과 조건
  What의 단계
  응용 분야(도메인)에 집중
  가장 중요하고도 어려운 단계
    조그만차이가 큰 오류로 변하기 떄문
  결과물 : 요구분석서(SRS)

설계
  How의 단계
  솔루션에 집중
  아키텍쳐 설계
  데이터베이스 설계
  UI설계
  상세 설계
  결과물 : 설계서

구현
  Do it 단계
  코딩과 단위 테스트
  설계 또는 통합 단계와 겹치기도 한다.
    전체 일정을 줄이기 위하여
    협력 작업이 필요한 경우
  특징
    압력 증가(부담감의 증가)
    최고의 인력 투입
  이슈
    Last minute Change
    Communication OverHead
    하청 관리

통합과 테스트
  병행
    통합해 나가면서 테스트 시작
  모듈의 통합으로 시작
  점차 완성된 모듈을 추가
  통합은 개발자가 주로 담당
  테스트는 QA 팀이 주로 담당
  단계적인 테스트
    단위, 통합, 시스템
    목적 중심 테스트
      스트레스 테스트, 성능 테스트, 베타 테스트, Acceptance 테스트,
      Usability 테스트

  설치와 유지보수
    시스템의 타입에 따라 다른 설치 방법
      Web-based, CD-ROM, In-house(시스템에 직접 설치후 시스템을 전달), etc
    이전 정책
      (전 시스템에서 현 시스템으로 바꾸는 정책)
    시스템 사용을 시작하게 하는 방법
      병행 운용(전시스템과 현시스템을 같이 사용해가면서 점진적으로 현시스템으로 바꿔가는 방법)
    설치는 개발 프로젝트의 일부, 유지보수는 별개
    유지보수
      결합을 고침
      새 기능 추가
      성능 추가

폭포수 모델
  계획 < - > 요구분석 < - > 설계 < - > 구현 < - > 시험 < - > 인수/설치
  각 단계가 다음 단계 시작전에 끝나야 함
    순서적 - 각 단계 사이에 중복이나 상호작용이 없음
    (상황에 따라 변화 가능)
    각 단계의 결과는 다음 단계가 시작 되기 전에 점검
    바로 전단계로 피드백
  단순한거나 응용 분야를 잘 알고 있는 경우 적합
    한번의 과정, 비전문가가 사용할 시스템 개발에 적합하다.
  결과물 정의가 중요하다.

  장점
    프로세스가 단순하여 초보자가 쉽게 적용 가능
    중간 산출물이 명확, 관리하기 좋음
    코드 생성 전 충분한 연구와 분석 단계
  단점
    처음 단계의 지나치게 강조하면 코딩, 테스트가 지연
    각 단계의 전환에 많은 노력
    프로토타입과 재사용의 기회가 줄어듦
    소용 없는 다종의 문서를 생산할 가능성 있음.
  적용
    이미 잘 알고 있는 문제나 연구 중심 문제에 적합
    변화가 적은 프로젝트에 적합.


프로토타이핑 모델(RAD(Rapid Prototyping Model))
  요구분석 -> 프로토타입(개발/개선) -> 프로토타입 평가 -> 구현 -> 인수/설치
      ^             ^                     v
      ------------------------------------- 반복
  프로토타입의 적용
    사용자의 요구를 더 정확히 추출
    알고리즘의 타당성, 운영체제와의 조화, 인터페이스의 시험 제작
  프로토타이핑 도구
    화면 생성기(목업 툴)
    비주얼 프로그래밍, 4세대 언어등
  공동의 참조 모델
    사용자와 개발자의 의사소통을 도와주는 좋은 매개체
  프로토타입의 목적
    단순한 요구 추출 - 만들고 버림
    제작 가능성 타진 - 개발 단계에서 유지보수가 이루어진다.

  장점
    사용자의 의견 반영이 잘됨
    사용자가 더 관심을 가지고 참여할 수 있고 개발자는 요구를 더 정확히 도출 할 수 있다.
  단점
    오해, 기대심리 유발
    관리가 어렵다(중간 산출물 정의가 난해)
  적용
    개발 착수 시점에 요구가 불투명할 떄
    실험적으로 실현 가능성을 타진해보고 싶을때
    혁신적인 기술을 사용해 보고 싶을떄
    (중소기업에서 사용함)

진화적 모델(릴리즈)
  개발 사이클이 짧은 환경
    빠른 시간안에 출시하여야 이윤에 직결 됨
    개발 시간을 줄이는 법 - 시스템을 나누어 릴리스(제품을 내놓음)

    개발자
      릴리즈1구축    릴리즈2구축    릴리즈3구축
    -------------------------------------------
    사용자
          릴리즈1사용    릴리즈2사용    릴리즈3사용
    (게임 -> 확장팩, 패치)
  릴리즈 구성방법
    점증적 방법 - 기능별로 릴리스(DLC)
    반복적 방법 - 릴리스 할때마다 기능의 완성도를 높임(패치)

  단계적 개발
    기능이 부족하더라도 초기에 사용 교육 가능
    처음 시장에 내놓은 소프트웨어는 시장을 빨리 형성 시킬 수 있음
    자주 릴리스 하면 가동중인 시스템에서 일어나는 예상하지 못했던 문제를 신속 꾸준히
      고쳐나갈수 있음.
    개발팀이 릴리스마다 다른 전문 영역에 초점을 둘 수 있음.
      (릴리스마다 전문적으로 요구하는것이 다름)

나선형 모델
  소프트웨어의 기능을 나누어 점증적으로 개발
    실패의 위험을 줄임
    테스트 용이
    피드백
  여러 번의 점증적인 릴리스
  진화 단계
    계획 수립(Planning) : 목표, 기능선택, 제약 조건의 결정
    위험 분석(Risk Analysis) : 기능 선택의 우선순위, 위험요소의 분석
    개발(Engineering) : 선택된 기능의 개발
    평가(Evaluation) : 개발 결과의 평가

  장점
    대규모 시스템 개발에 적합 - Risk Reduction Mechanism
    반복적인 개발 및 테스트 - 강인성 향상
    한 사이클에 추가 못한 기능은 다음 단계에 추가가능
  단점
    관리가 중요
    위험 분석이 중요
    새로운 모형
  적용
    재정적 또는 기술적으로 위험 부담이 큰 경우
    요구 사항이나 아키텍처 이해에 어려운 경우

V 모델
                          인수/설치
  요구분석 ----------- 시스템 테스팅  --> 요구분석 검증
    시스템 설계 ---- 통합 테스팅      --> 인터페이스 검증
      상세 설계 -- 단위 테스팅        --> 모듈 검증
               코딩
  폭포수 모형의 변형
    감추어진 반복과 재 작업을 드러냄
    작업과 결과의 검증에 초점
  장점
    오류를 줄일 수 있음
  단점
    반복이 없어 변경을 다루기가 쉽지 않음
  적용
    신뢰성이 높이 요구되는 분야에서 사용됨.

Unified 프로세스
    도입 정련 구축 전환 의 과정 동안 반복작업 수행
    (각 단계별 진행도 별로 작업량의 차이가 있음)
  비즈니스 모델링
  요구분석
  설계
  구현
  테스팅
  설치
  형상 관리
  프로젝트 관리

  사용사례 중심의 프로세스
  시스템 개발 초기에 아키텍처와 전체적인 구조를 확정
  아키텍처 중심
  반복적이고 점증적

애자일 프로세스
  폭포수 프로세스의 단점을 해결
  절차와 도구보다 개인과 소통을 중요시 한다
  잘 쓴 문서보다는 실행되는 소프트웨어에 더 가치를 둔다.
  계약 절충보다는 고객 협력을 더 중요하게 여긴다.
  계획을 따라 하는것보다 변경에 잘 대응하는 것을 중요하게 여긴다.

  사용사례 또는 사용자 스토리나 피처 단위
  테스트 중심 개발
  (사용자가 함께 개발)

  점증적 계획 - 지속적인 사용자와의 커뮤니케이션 -> 지속적인 리뷰와 테스팅
  -> 설치 가능한 프로덕트 -> 적응적 팀구성 -> 변동 가능성 있는 요구 -> 반복

관리 프로세스
  비용과 품질 목표를 달성하기 위하여 프로젝트 관리하는데 필요한 모든 작업
    계획, 모니터링과 제어, 분석
  프로젝트 모니터링과 제어는 개발 프로세스의 모든 단계를 포함하므로 가장
  긴 기간 동안 이루어짐

  개발 프로세스 모델을 구축할 때 개발 각 단계마다 관리 프로세스를 위한 정보를 생성하도록 정의
  관리 프로세스와 개발 프로세스 사이의 관계

  관리 프로세스가 개발 프로세스의 단계별로 계속 확인 (제어)

형상 관리 프로세스
  개발 중에 발생하는 변경을 체계적으로 컨트롤 하는것
  개발작업과 독립적인 작업

    프로그램의 최신 버전 유지(버전관리)
    지정된 버전으로 되돌아 갈 수 있는 기능
    무허가 변경이나 삭제를 방지(권한관리)
    현 시스템에 대한 모든 정보, 문서등의 정보를 모아 보관

  형상관리 메커니즘
    프로젝트에서 변경이 발생되었을때 처리하는 시나리오를 다루는 메커니즘을 제공
      형상 관리 대상 파악과 베이스 라인 지정
      버전관리
      접근제어
    형상관리 아이템의 생명주기

            <-----(불허)
      개발중 ----> 검토중 ----> 형상관리
          개발자만족       승인(ok)

방법론
  소프트웨어 프로세스의 각 작업을 어떻게 수행하느냐를 정의

프로세스
  일반적으로 개발할 때 해야하는 작업만을 명시
  어떤 관계가 있는지 나타내지 않음



구조적 방법론
  분리와 정복원리 적용

  자료 흐름도를 구조도로 변경하는 과정
    구조도(DFD) 모듈 사이의 관계를 나타내는 그래프

객체지향 방법론
  자료와 함수를 가까운 곳에 정의하여 객체로 묶어두고 객체 사이에 메시지를 호출하여 원하는 기능을 담당하게 하는것

애자일 방법론
  점증적인 프로세스를 채택
  짧은 반복 주기를 반복하며 점증적으로 자주 출시
  익스트림 프로그래밍
  스크럼
  기능 중심 개발

  익스트림 프로그래밍
    소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하는 경우
    탐구
    계획
    반복
    제품화
    유지보수
    종료

  스크럼
    소프트웨어 개발팀이 개발을 연습하고 능력을 향상시킬 수 있는 프레임워크

  기능 중심 개발
    여섯 단계로 구성
      처음 세 단계는 한번만, 나중 세 단계는 반복되는 과정
    전체 모델 개발
    기능 리스트 구축
    기능 단위의 계획
    기능 단위의 설계, 구축, 설치
